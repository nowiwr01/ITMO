## [Задача 1. Автодополнение](https://github.com/nowiwr01/itmo/tree/master/c%2B%2B/autocomplete/)
# Задание
Напишите реализацию автодополнения для N строк и положительных весов. На выход программе нужно выдать все строки, которые начинаются с заданного префикса в порядке убывания весов.
 
Автодополнение очень чувствительно к скорости работы. Поэтому автодополнение нужно реализовать на отсортированном множестве, а поиск в этом множестве нужно делать бинарным поиском.
 
Задание состоит из трёх частей:
 
# Часть 1
Нужно реализовать неизменяемый класс term, который содержит в себе:
  * Конструктор принимающий строку и её вес
  * Операторы сравнения термов
  * Конструкторы/операторы копирования, присваивания, перемещения должны работать корректно
  * Метод to_string который возвращает строковое представление строки в формате "weight term"
  * Оператор вывода в поток (тот же формат, что и результат to_string)
  * Метод by_reverse_weight_order который возвращает функтор принимающий на вход два терма и сравнивает их с учётом весов в обратном порядке
  * Метод by_prefix_order(int r) который возвращает функтор принимающий на вход два терма и сравнивает их по первым r символам без учёта весов
 
# Часть 2
Нужно реализовать класс binary_search_deluxe, который реализует бинарный поиск и удовлетворяет требованиям:
  * Экземпляр этого класса нельзя создавать
  * Статический метод int first_index_of(term[] a, term key, Func comparator), который принимает отсортированный массив a и должен выдать индекс начала key в массиве a
  * Статический метод int last_index_of(term[] a, term key, Func comparator), который принимает отсортированный массив a и должен выдать индекс конца key в массиве a
 
Func comparator - это некоторый объект (класс с переопределённым оператором круглые скобки, функция, лямбда), который прнимает два терма и возращает true если первый терм меньше второго. Пример такого компаратора:
```
auto cmp = [](const term& t1, const term& t2) { return t1 > t2; };
```
Вместо Func Вам нужно написать такой тип для которого случаи: класс с переопределённым оператором круглые скобки, функция и лямбда будут компилироваться и работать корректно.
 
# Часть 3
Нужно реализовать неизменяемый класс autocomplete, который использует внутри себя term и binary_search_deluxe. Этот класс должен содержать в себе следующие методы:
  * Конструктор, принимающий массив термов
  * Метод all_matches(string prefix) возвращает массив термов, которые подходят под заданный префикс
  * Метод number_of_matches(string prefix) возвращает количество термов, которые подходят под заданный префикс

## [Задача 2. Puzzle Game](https://github.com/nowiwr01/itmo/tree/master/c%2B%2B/puzzle_game/)
# Задание
Написать программу, которая решает головоломку 8 Puzzle (и её обобщения) с использованием алгоритма A*.

https://en.wikipedia.org/wiki/15_puzzle

https://en.wikipedia.org/wiki/A*_search_algorithm

# Реализуйте класс board
Вам необходимо реализовать неизменяемый класс доски, который будет удовлетворять следующим требованиям:
  * Конструктор без параметров
  * Конструктор, принимающий массив в пространстве размерности 2, который заполнен целыми числами
  * Конструктор, принимающий размер доски и генерирующий некоторое состояние на доске
  * Метод size, возвращающий размер доски
  * Метод hamming, возвращающий количество блоков не на своих местах
  * Метод manhattan, возвращающий сумму Manhattan расстояний между блоками и целью
  * Метод is_goal, который отвечает на вопрос является ли эта доска целью
  * Метод is_solvable, который отвечает на вопрос, решаема ли такая расстановка элементов
  * Операторы == и != для board
  * Метод to_string и операторы вывода для текстового представления строк
  * Такой синтаксис должен работать: board b(3); std::cout << b[1][1] << std::endl;, выводит элемент в ячейке (1, 1)
  * Конструкторы копирования и операторы присваивания должны работать корректно

# Реализуйте класс solver
Этот класс должен предоставлять интерфейс для получения цепочек досок, которые приводят к решению, и удовлетворять следующим требованиям:
  * Конструктор, принимающий board, для которого нужно построить решение
  * Метод moves, который выводит количество перемещений, которые приводят к решению
  * Итератор, который позволяет пройтись по последовательности board, приводящей к решению
  * Конструкторы копирования и операторы присваивания должны работать корректно
Если решения не существует, тогда begin() == end(). Т.е. в решении должно быть 0 досок которые приводят к ршению.

# [Задача 3. Рандомизированная очередь и дек](https://github.com/nowiwr01/itmo/tree/master/c%2B%2B/randomized_queue_and_deque)
# Задание
Необходимо реализовать шаблонные структуры данных: рандомизированную очередь (randomized_queue) и дек (deque). В задании разрешается использовать следующие структуры данных: std::list, std::vector, std::array. Остальную часть, не относящуюся к структурам данных, можно использовать по своему усмотрению.
 
Рандомизированная очередь - это коллекция, которая предоставляет доступ к своим элементам в случайном порядке. Таким образом, каждый отдельный "взгляд" на эту коллекцию даёт случайную, независимую от других, перестановку элементов. Например, если взять два итератора на начало коллекции, а затем каждым пройти по всем элементам до конца, то эти два прохода дадут две разных, независимых друг от друга, перестановки.
 
Пример: исходная коллекция = 1, 2, 3, 4, 5, 6
 
Перестановки:
 
6, 2, 4, 1, 5, 3
 
5, 3, 2, 6, 4, 1
 
2, 6, 4, 5, 3, 1
 
Подобный код должен работать:
 
```
randomized_queue<int> q;
for (int i = 0; i < 5; ++i) {
    q.enqueue(i);
}
auto b1 = q.begin();
auto e1 = q.end();
auto b2 = q.begin();
auto e2 = q.end();
 
std::vector<int> v11, v12;
std::copy(b1, e1, std::back_inserter(v11));
std::copy(b1, e1, std::back_inserter(v12));
assert(v11 == v12); // Два прохода одним итератором дают одинаковую последовательность
 
std::vector<int> v21, v22;
std::copy(b2, e2, std::back_inserter(v21));
std::copy(b2, e2, std::back_inserter(v22));
assert(v21 == v22); // Два прохода одним итератором дают одинаковую последовательность
 
assert(v11 != v21); // С высокой степенью вероятности, два разных итератора задают разные последовательности
 
// взятие итераторов не повлияло на очередь
while (!q.empty()) {
    std::cout << q.dequeue() << ' ';
}
```
 
# Требования к дек
  Необходимо создать шаблонную реализацию deque, которая удовлетворяет следующим условиям:
  * конструктор без параметров
  * метод empty, который отвечает на вопрос о пустоте структуры данных
  * метод size возвращает количество элементов в структуре данных
  * должны быть реализованы итераторы
  * методы push_front, push_back - добавляют в начало/конец структуры данных элемент
  * методы front, back - позволяют посмотреть на элемент в начале и конце
  * методы pop_front, pop_back удаляют элемент из дека, с начала и с конца соотвественно.
 
# Требования к рандомизированной очереди
Необходимо создать шаблонную реализацию randomized_queue, которая удовлетворяет следующим условиям:
  * конструктор без параметров
  * метод empty, который отвечает на вопрос о пустоте структуры данных
  * метод size возвращает количество элементов в структуре данных
  * должны быть реализованы итераторы (в том числе, позволяющие модификацию элементов очереди)
  * методы enqueue - добавляют в структуру данных элемент
  * методы sample - позволяют посмотреть случайный элемент, но при этом не удаляет его
  * методы dequeue - возвращает случайный элемент и удаляет его из из дека
 
# Клиентская программа subset
  * Нужно разработать утилиту с названием subset, которая принимает список строк и выдаёт k из них с равномерным распределением. Для этого нужно использовать разработанные структуры данных. При этом "строка" - это произвольная последовательность печатных символов, ограниченная символом перевода строки (\n).
 
In: printf '%s\n' A B C D E F G H I | subset 3

Out: C G A
